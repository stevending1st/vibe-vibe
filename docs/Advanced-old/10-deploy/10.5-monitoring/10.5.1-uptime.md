---
title: "10.5.1 网站还活着吗——应用监控：健康检查端点与指标收集"
typora-root-url: ../../public
---

# 10.5.1 网站还活着吗——应用监控：健康检查端点与指标收集

每 5 分钟问一次"你还好吗"，比用户告诉你"挂了"好得多。

## 健康检查原理

```mermaid
flowchart LR
    A[监控服务] -->|定时请求| B[/health]
    B -->|200 OK| C[正常]
    B -->|非200/超时| D[告警]
```

## 健康检查端点设计

### 基础版本

```typescript
// NestJS health.controller.ts
@Controller('health')
export class HealthController {
  @Get()
  check() {
    return { status: 'ok' };
  }
}
```

### 完整版本

```typescript
@Controller('health')
export class HealthController {
  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  @Get()
  async check() {
    const checks = {
      status: 'ok',
      timestamp: new Date().toISOString(),
      services: {},
    };

    // 检查数据库
    try {
      await this.prisma.$queryRaw`SELECT 1`;
      checks.services['database'] = 'ok';
    } catch {
      checks.services['database'] = 'error';
      checks.status = 'degraded';
    }

    // 检查 Redis
    try {
      await this.redis.ping();
      checks.services['redis'] = 'ok';
    } catch {
      checks.services['redis'] = 'error';
      checks.status = 'degraded';
    }

    return checks;
  }

  @Get('live')
  liveness() {
    return { status: 'ok' };
  }

  @Get('ready')
  async readiness() {
    // 检查所有依赖是否就绪
    await this.prisma.$queryRaw`SELECT 1`;
    return { status: 'ok' };
  }
}
```

## 健康检查类型

| 类型 | 端点 | 用途 |
|------|------|------|
| Liveness | `/health/live` | 进程是否存活 |
| Readiness | `/health/ready` | 是否可以接收流量 |
| Startup | `/health/startup` | 启动是否完成 |

## 外部监控服务

### UptimeRobot（推荐）

免费版支持 50 个监控：

1. 注册 [UptimeRobot](https://uptimerobot.com/)
2. 添加新监控
3. 配置：
   - 监控类型：HTTP(s)
   - URL：`https://api.example.com/health`
   - 间隔：5 分钟
   - 告警联系人：邮箱/Webhook

### Better Stack（日志+监控）

```javascript
// 集成 Better Stack SDK
import { Logtail } from '@logtail/node';
const logtail = new Logtail('your-source-token');

logtail.info('Application started');
```

## 1Panel 服务器监控

1Panel 内置服务器监控：

| 指标 | 说明 |
|------|------|
| CPU 使用率 | 整体/各核心 |
| 内存使用 | 已用/可用/缓存 |
| 磁盘使用 | 各分区使用率 |
| 网络流量 | 入站/出站 |

路径：面板首页 → 监控

## Docker 容器监控

### docker stats

```bash
# 实时查看容器资源使用
docker stats

# 输出示例
CONTAINER ID   NAME     CPU %   MEM USAGE / LIMIT   NET I/O        BLOCK I/O
abc123def456   api      0.50%   256MiB / 1GiB       1.2MB / 500KB  0B / 0B
```

### 监控容器健康

```yaml
# docker-compose.yml
services:
  api:
    image: my-api
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
```

## 关键指标

### 服务器指标

| 指标 | 警戒值 | 说明 |
|------|--------|------|
| CPU 使用率 | > 80% | 考虑扩容 |
| 内存使用率 | > 85% | 可能 OOM |
| 磁盘使用率 | > 90% | 清理日志 |
| 网络带宽 | > 80% | 升级带宽 |

### 应用指标

| 指标 | 警戒值 | 说明 |
|------|--------|------|
| 响应时间 | > 2s | 性能问题 |
| 错误率 | > 1% | 代码问题 |
| QPS | 接近上限 | 考虑扩容 |

## 自定义指标收集

### 简单计数器

```typescript
// 统计 API 调用次数
const apiMetrics = {
  totalRequests: 0,
  errorRequests: 0,
  
  record(success: boolean) {
    this.totalRequests++;
    if (!success) this.errorRequests++;
  },
  
  getStats() {
    return {
      total: this.totalRequests,
      errors: this.errorRequests,
      errorRate: this.errorRequests / this.totalRequests,
    };
  }
};

@Get('metrics')
getMetrics() {
  return apiMetrics.getStats();
}
```

## 监控最佳实践

1. **多层次监控**：服务器 + 应用 + 业务
2. **合理间隔**：外部监控 5 分钟，内部可更频繁
3. **避免误报**：设置重试次数，连续失败才告警
4. **监控监控**：确保监控服务本身可用
5. **文档记录**：记录各指标的含义和阈值

## 常见问题

| 问题 | 原因 | 解决方案 |
|------|------|----------|
| 误报太多 | 阈值设置不合理 | 调整阈值，增加重试 |
| 监控延迟 | 检查间隔太长 | 缩短间隔（但注意成本） |
| 无法访问 | 网络/防火墙问题 | 检查安全组规则 |
