---
title: "第二章：开发工具与 AI 调教指南"
---

# 第二章：开发工具与 AI 调教指南
## 序言
环境装好了，你手里握着一份庞大的工具清单，面对 **Deepseek、豆包、千问、GLM、GPT、Claude、Gemini** 这些模型，还有 **Cursor、Trae、Windsurf** 甚至 **Qoder、Code Buddy** 这些编辑器，以及 **Claude Code, CodeX, Qoder CLI, Droid CLI, Warp** 等各种 CLI 命令行工具，你彻底晕了。

你不知道它们之间有什么区别。经过老师傅的介绍，你终于明白了：**模型决定推理能力的上限，工具决定代码实现的效率。** 最终，你确定了适合自己的组合。

你想了一个 Demo 随便试了一下，发现 AI 给的方案五花八门，有时候想按照自己的心意修改，结果改了这里坏了那里，引发连锁问题。

你开始意识到需要统一标准。在老师傅的引导下，知道了要写 **PRD（产品需求文档，见下一节）**，并明白了“单一事实来源”的重要性：**不要让 AI 猜你想做什么，而是用文档告诉它必须做什么。**

除了选对工具，老师傅还传授了你三招让 AI 更加好用的技巧，解决了 AI 记性差、瞎胡写的问题：

### 第一招：配置插件 (MCP) —— 赋予 AI 外部操作能力

老师傅提到了 **MCP (Model Context Protocol)**，你可以把它理解为插件。以前你只能问 AI 问题，现在通过配置 MCP，你可以让 AI **连接 GitHub 仓库**看代码，**连接 PostgreSQL 数据库**查数据，读取 **Figma** 设计稿，甚至接入 **Stripe** 支付。你不需要懂底层原理，只需要简单配置，你的 AI 就拥有了操作外部工具能力。

### 第二招：自定义技能 (Skills) —— 定义常用指令

针对 **Claude Code** 这样的 CLI 工具，老师傅教你创建或者安装 **Skills**。在这里，你可以用自然语言定义专属的指令，比如“每当我说‘分析数据’时，就自动运行 `node scripts/analyze.js` 并总结结果”。这相当于为 AI 定义了一套标准作业流程，让它学会了你专属的工作流。

### 第三招：项目规则 (Project Rules) —— 设定项目规范

你之前总抱怨 AI 忘记你用的是 shadcn 还是 Tailwind，或者总是写错 TypeScript 类型。老师傅让你在项目根目录新建一个 **`.cursorrules`**（或 `.windsurfrules` 等）文件。你在里面写上：“禁止使用 `any` 类型”、“强制使用 `pnpm`”。从此以后，AI 每次写代码前都会先参考这份**项目规范**，生成的代码质量瞬间提升，再也不胡乱引入你没安装的库了。

你庆幸自己选择了 AI IDE 或 CLI 工具，而不是在网页版对话框里手动复制粘贴。你发现，工具能直接读取你的项目上下文，生成的修改建议可以直接通过点击按钮无缝合并到代码中。这意味着你**不会**遇到那些手动复制粘贴时常犯的错误——比如不小心把 AI 偷懒生成的 `// ... rest of code` 注释也复制进文件导致程序崩溃。此外，你还发现可以给工具更高的权限，他们在执行大部分命令时都不需要你的批准，实现了高度的自动化，你可以趁机干自己的事情。

你深刻意识到：**Vibecoding 的核心不仅是 Prompt（提示词），更是 Workflow（工具流）。**

即便有了这些神器，开发过程中也难免会遇到满屏红字的报错。这时，老师傅向你传授了两个解决 Bug 的终极心法，让你从此告别慌乱：

- **提供完整报错日志**：面对终端或者控制台里满屏的红色报错日志，新手往往因为害怕只描述“报错了”或者只复制最后一行。老师傅告诉你，AI 需要的是完整的线索。你应该把那些**看起来最长、最复杂的红色报错日志——原封不动地全选、复制并发送给 AI**。只有提供了完整的信息，AI 才能精准定位是哪一行代码出了问题，而不是在那盲目推测。
- **循环修复模式 (Loop Fix)**：更高级的玩法是利用 AI IDE 的终端集成功能。现在的工具通常都能直接读取你的终端报错。你甚至不需要手动复制粘贴，只需要在对话框里下令：“**帮我构建项目，检查所有报错并自动修复。**” AI 会自动运行命令，读取错误，修改代码，再运行。你只需要让 AI **循环这个“运行-报错-修复”的过程**，通常几个回合下来，绝大部分棘手的 Bug 都会被自动消灭。

*如果这也解决不了？* 这意味着你可能需要更换模型、新开一个对话（清空缓存）、提供更多的项目文档（补充上下文），或者学习更多知识以引导 AI 往正确的方向思考。

看着你跃跃欲试准备让 AI 大改代码，老师傅突然按住了你的手，问了一个问题：“**如果 AI 这一次改错了，把你本来能跑的代码改崩了，甚至把你昨天的功能覆盖了，你怎么办？**” 你意识到，如果没有版本控制，错误的修改可能导致之前的成果无法恢复。

老师傅告诉你，AI 编程非常激进，它可能为了修一个 Bug 而破坏三个旧功能。所以，在开始大规模开发之前，你必须配置好 **Git**。在这一阶段，你不需要懂什么复杂的“远程仓库”或“分支策略”，你只需要利用它建立高频的**本地版本记录**。

既然代码是 AI 写的，那么维护版本这种重复性工作也应该全权交给 AI，完全不需要你操心。老师傅传授了一句**写在 AI 规则里的指令**，让版本管理成为自动化的常规流程：

> **“每当你完成一个独立功能的开发，或修复完一个 Bug 并验证通过后，请自动运行 git commit 提交代码，并生成一句简洁的中文 commit message。”**

从此，你的开发流程变成了：AI 写完登录功能 → 自动存档；AI 写完首页 → 自动存档。一旦 AI 在写“个人中心”时把整个项目搞崩了，你不需要慌张，让 AI 帮你回退到上一个版本即可。这能确保在代码出现问题时迅速恢复，保障开发进度。

