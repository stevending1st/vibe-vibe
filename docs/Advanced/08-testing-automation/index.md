---
title: "第八章：功能测试流程与自动化脚本"
---


![08-testing-automation_index.png](../../public/images/Advanced/08-testing-automation_index.png)
# 第八章：功能测试流程与自动化脚本
## 序言
功能越来越多了，你开始遇到一个崩溃的现象：**“打地鼠”**。你刚修复了“登录页”的 Bug，结果“注册页”又打不开了；你优化了首页的样式，结果购物车按钮点不动了。

老师傅告诉你，要防止这种"牵一发而动全身"的惨案，得两手抓： **首先是"内功"：合理规划代码结构和文件夹**。不要把所有逻辑都堆在一个文件里，而是要将不同的功能拆分到独立的模块（比如 `components/` 放积木，`lib/` 放工具函数，`app/` 放页面）。结构清晰了，改动 A 模块自然就不容易误伤 B 模块。 **其次是"外功"：回归测试**。每次修改代码，你都必须把以前所有能跑的功能都测一遍，确保没有被新代码"误伤"。但靠人肉在网页上点点点，既累又容易漏。

**不过，老师傅也给了一句务实的忠告：** 自动化虽然爽，但也不是必须的。如果你的项目一共就两个页面，或者还在疯狂改需求的阶段，那还是**直接上手点点**更实惠。自动化测试是为了解决**大规模、重复性**劳动的，不要为了自动化而自动化，陷入写脚本的时间比写代码还长的陷阱。



### Playwright 简介

老师傅推荐了 **Playwright**。你可以把它理解为**自动化浏览器控制工具**。它拥有一个真实的浏览器内核，能以比人类快 100 倍的速度，模拟你的鼠标点击、键盘输入甚至上传文件。更重要的是，它**不知疲倦**。哪怕半夜 3 点，只要你一声令下，它就能在几秒钟内把"登录-下单-支付"的全流程跑 100 遍，而且绝不会看走眼。

为什么选择 Playwright 而不是其他测试框架？首先它跨浏览器（Chrome、Firefox、Safari 都支持），其次快速稳定（支持并行执行、自动等待元素出现），最重要的是 AI 友好——可以用 `npx playwright codegen` 录制手动操作，自动生成测试代码。Playwright 的核心概念很简单：Page 代表浏览器页面，Locator 用来定位元素，Assertion 做断言判断。测试金字塔理论建议 60% 单元测试、30% 集成测试、10% E2E 测试，E2E 测试虽然占比小，但覆盖的是核心业务流程（登录、注册、支付），价值最高。AI 还能帮你优化测试用例，添加边界情况和错误处理。测试的价值不是发现 Bug，而是防止 Bug 回归——修复 Bug A 时不会引入 Bug B。

在 VibeCoding 过程中，编写测试脚本不再是高级测试工程师的专利，在成熟的 AI 编程工具里，你只需要在对话框中**引用**你的业务代码文件（通常是输入 `@` 符号选择文件，或者粘贴文件路径，甚至直接把文件拖入对话框）。虽然现在的 AI 很聪明，能自己在全项目里翻箱倒柜找代码，但如果你能**手动指定文件路径**，AI 的反应会快得多，写出的测试也更精准。

### UI 测试

对于用户界面 (UI) 的测试，你只需要在 Chat 框里引用 `app/login/page.tsx`（假设这是你的登录页），然后下令："**阅读这个文件，为我写一个 Playwright 测试脚本。测试场景包括：1. 输入错误的密码应提示错误；2. 输入正确的密码应跳转到首页。**" AI 会立即读取你指定的文件内容，分析组件结构，精准地生成包含导航、操作、验证全流程的代码。

### API 测试

除了测试界面，老师傅提醒你别忘了测试后端接口 (API)。有时候页面报错不是因为按钮坏了，而是因为后端的接口挂了。Playwright 不仅能模拟浏览器，还能直接发送 HTTP 请求。你不需要一个个接口去写测试，而是直接引用整个 `app/api` 文件夹，给 AI 下达一个宏大的指令：

> **“阅读 `app/api` 文件夹下的所有路由文件，理解每个 API 的业务逻辑。然后为每一个 API 生成对应的测试脚本，覆盖正常请求（200 OK）和常见的错误请求（400/500）场景。”**

AI 会迅速遍历你指定的路径，分析出你有注册、登录、获取文章列表等十几个接口，并自动为它们生成一整套严密的测试代码。这种方式速度极快，能帮你迅速定位到底是前端展示逻辑的问题，还是后端数据处理的问题。

### 运行测试

最后，你学会了运行 `npx playwright test`。看着终端里一行行绿色的 **PASS** 飞速滚动，那种安全感是前所未有的。这意味着你的代码在逻辑上是**可靠**的。老师傅还教你打开了 Playwright 的**可视化模式 (UI Mode)**。看着屏幕上一个自动化的浏览器窗口飞速闪动，自动填表单、点按钮，你第一次体会到了工业化开发的爽快感。你确保了在面对真实用户前，把那些低级的逻辑 Bug 全部消灭在了萌芽状态。

### 测试驱动开发

不过，老师傅告诉你，还有更高级的玩法。你现在是先写代码，再补测试，这叫"测试驱动开发（TDD）"的反向版本。在 AI 编程时代，**真正的 TDD 是先写测试，再写代码**。为什么要这样做？当你给 AI 一个明确的测试目标，它的表现会显著提升。

老师傅向你介绍了 **TDD（测试驱动开发）** 工作流：
1. **先写测试**：基于预期的输入/输出对编写测试，明确告诉 AI 你在进行 TDD，避免它创建模拟实现
2. **运行测试，确认失败**：在这个阶段明确告诉 AI 不要编写任何实现代码
3. **提交测试**：当你对测试满意时，让 AI 提交测试
4. **编写代码，直到测试通过**：让 AI 编写通过测试的代码，指示它不要修改测试。通常需要几次迭代
5. **提交代码**：当你对更改满意时，让 AI 提交代码

你试了一次，发现写测试的过程其实就是在"设计接口"。当你写测试时，你会思考"这个方法应该接收什么参数、返回什么结果"，这个思考过程比直接写代码更重要。虽然刚开始觉得慢，但很快发现返工次数大幅减少。更重要的是，你发现测试其实是最好的"设计工具"，它迫使你在写代码之前就想清楚接口和逻辑。

老师傅告诉你，这种自动化还可以更进一步 —— 通过配置 **Hooks**，每当 AI 修改代码后，自动运行相关测试。你不需要手动敲命令，整个测试流程就自动完成了。这种"自动化中的自动化"，我们会在后续内容中深入探索。



