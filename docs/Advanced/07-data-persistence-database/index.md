---
title: "第七章：数据持久化与数据库"
---

# 第七章：数据持久化与数据库
## 序言
界面搭建得有模有样了，但你发现一个尴尬的问题：每次刷新网页，刚才填写的表单、生成的对话全都不见了。

老师傅告诉你，这是因为浏览器里的数据默认只存储在临时的**内存**中。想要数据在关闭或刷新页面后依然存在，你需要**数据持久化**。

他严肃地提醒你：**数据是所有业务的基石**。前端代码丢了可以重写，UI 丑了可以换皮，但如果数据库里的用户数据丢了、乱了，你的产品就彻底完了。这就是为什么后端开发往往比前端更注重严谨性——因为你守护的是产品的灵魂。

持久化不一定上来就要装复杂的软件。最简单的方式，其实就是把你之前在配置文件里学到的 **JSON** 格式利用起来，把数据存成 `.json` 文件。每一条聊天记录或用户信息，本质上就是一段文本。把它保存进硬盘的文件里，下次读取文件就能恢复。这种方式让你瞬间理解了“数据库”的本质——**无非就是高效地读写硬盘上的文件。**

---

虽然 JSON 文件简单，但当你数据多了，想找“所有住在北京且年龄大于 20 岁的用户”时，就需要遍历整个文件，效率极低。于是你接触到了 **Relational Databases（关系型数据库）**。老师傅让你把它想象成一个**超级 Excel**，理解它只需要掌握几个关键点：

- **Table (表)**：就是一个 Excel Sheet（工作表），比如 `Users` 表。
- **Row (行)**：表里的一行，代表一条具体的数据（比如用户张三）。
- **Column (列)**：表里的表头，定义了数据有哪些属性（姓名、年龄、邮箱）。
- **Primary Key (主键)**：每一行数据的唯一身份证号（通常是 `id`），绝对不能重复。
- **Foreign Key (外键)**：用来关联其他表的线索。比如在 `Orders`（订单）表中记录一个 `user_id`，就能顺藤摸瓜找到这个订单属于哪个用户。

**实战秘籍：如何判断 AI 设计的表结构好坏？** 新手往往很难一眼看出 Schema 设计得合不合理。老师傅传授了你一招**“AI 交叉论证法”**（俗称“炼蛊”）：你让 ChatGPT 帮你设计好表结构，然后把生成的代码发给 Claude 或 Deepseek，问它：“**作为一个资深数据库架构师，请批判一下这个设计有什么潜在的性能隐患或逻辑漏洞？**” 通常经过两轮这样的“左右互搏”，你就能得到一个非常健壮的数据库模型。

---

就像你用 JavaScript 指挥浏览器一样，指挥数据库也有专门的语言，叫 **SQL**。但在 Vibecoding 中，你不需要专门去学 SQL，因为我们有 **Prisma**。你只需要看懂它的“蓝图文件”——`schema.prisma`。

你可能会问，这个复杂的文件是谁写的？是你需要背诵语法然后一个字一个字敲出来的吗？当然不是。它是 **AI 从你的 PRD 文档里“悟”出来的**。当你在 PRD 里写下“一个用户可以发布多篇文章”时，AI 读懂了这层业务逻辑，于是它自动在 `User` 表里加上了 `posts` 字段，在 `Post` 表里加上了 `authorId` 字段。**你的工作不是写代码，而是检查 AI 是否正确理解了你的意图。**

为了能看懂 AI 交的作业，老师傅指着一段代码，逐行教你认字：

```
model User {
  id        Int      @id @default(autoincrement())  // 整数类型，作为主键，自动+1
  email     String   @unique                        // 字符串类型，必须唯一
  name      String?                                 // 字符串类型，但在类型后面加了问号，表示“可选项”（可以不填）
  createdAt DateTime @default(now())                // 时间类型，默认填入当前时间
  posts     Post[]                                  // 关联关系：一个用户可以有多篇文章
}
```

- **`model`**：这就代表一张**表**。
- **类型**：`Int`（整数）、`String`（文本）、`Boolean`（真假）、`DateTime`（时间）。
- **`?`（问号）**：这是新手的救星。它代表 **Optional（可选）**。如果你不确定一个字段是不是必填的（比如用户的“个人简介”），加上问号，数据库就允许它为空，否则一旦没填程序就会报错。
- **`@unique`**：代表这个内容（如邮箱）全表唯一，不能重复注册。

虽然不用写 SQL，但你必须把 **CRUD**（Create 增、Read 查、Update 改、Delete 删）刻在脑子里。**这是所有数据库操作的基石，也是你指挥 AI 操作数据的核心通用术语。**

---

为了实战，你接触到了 **SQLite**，它是一个轻量级的文件数据库，不需要安装，非常适合开发测试。但为了未来的扩展性，老师傅建议你使用 **PostgreSQL**。

为什么是 PostgreSQL？除了它是世界上最强大的开源关系型数据库之一，它还有两个让 AI 开发者无法拒绝的特性：

1. **JSONB 支持**：它虽然是关系型数据库，但能像 NoSQL 一样直接存 JSON 数据。这意味着你可以把 AI 生成的那些结构不确定的复杂数据直接丢进去，既有规则（SQL）又有灵活性（NoSQL）。
2. **pgvector（向量检索）**：这是 AI 时代的杀手锏。它可以存储和查询“向量数据”，这是实现 **AI 长期记忆**（RAG）的核心技术。选了 PostgreSQL，就等于为你的 AI 应用铺平了未来的路。

在实操中，有两个新手必踩的坑：

**坑一：Connection URL（连接字符串）** 你经常看到 `Error: Invalid URL` 的报错。老师傅告诉你，连接数据库就像寄信，格式必须严格遵守：`postgresql://用户名:密码@主机地址:端口/数据库名`。任何一个标点符号错了，或者密码里包含了特殊字符（需要转义），都会导致连接失败。

**坑二：Schema 与代码不同步（最重要的命令）** 你让 AI 在数据库里增加了一个 `phone` 字段，AI 修改了 `schema.prisma` 文件。但当你运行代码时，程序却炸了，提示“User 上不存在 phone 属性”。你开始怀疑人生，老师傅却淡定地让你运行一句命令：`npx prisma generate`。

原来，Prisma 为了保证 TypeScript 的类型安全，需要根据 Schema 生成一份“类型定义文件”。**每当你修改了数据库结构（Schema），都必须重新运行 generate 命令**，告诉代码：“嘿，数据库结构变了，请更新你的认知。”

老师傅特意叮嘱：**这个命令非常重要，以至于在未来你部署上线时（比如在 Vercel 的 Build Command 里），也必须把它加进去**，否则线上的代码会因为不认识新的数据库结构而报错。

